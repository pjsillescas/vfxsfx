\documentclass[12pt]{article}%

\usepackage{amsmath}%
\usepackage{amsfonts}%
\usepackage{amssymb}%
\usepackage{graphicx}
\usepackage{array}
\usepackage{verbatim}
%\usepackage{hyperref}
\usepackage{listings}

\PassOptionsToPackage{hyphens}{url}
\usepackage{hyperref}

\usepackage[a4paper, total={6in, 8in},margin=3cm]{geometry}
%\usepackage[a4paper, total={6in, 10in}]{geometry}

\renewcommand{\figurename}{Figura}

\begin{document}
\sloppy

\title{PEC2: Fuego en el Shader}
\author{Pedro Jesús Sánchez Illescas}

\lstdefinestyle{glsl}
{
	language=c,
	%numbers=left,
	%stepnumber=1,
	%numbersep=10pt,
	tabsize=2,
	showspaces=false,
	showstringspaces=false,
	basicstyle=\footnotesize\ttfamily
}


\maketitle

\newpage

\tableofcontents

\newpage

\section{Librerías utilizadas}
\begin{itemize}
	\item SDL 2.30.0
	\item SDL-image 2.8.2
\end{itemize}

\section{Proceso de creación}
	
	Este proyecto se ha desarrollado partiendo del código del reto 15 del cuaderno junto con el minimotor de efectos desarrollado en la práctica anterior, con leves modificaciones para poder dibujar usando ventanas OpenGL en lugar de superficies y la posibilidad de usar input del usuario en los efectos. El primer paso ha consistido en refactorizar el código inicial con los objetivos de tener un código más compacto y profundizar en la comprensión del procedimiento. Gracias a este paso, el agua se ha renderizado usando un solo objeto \textit{WaterObject} que engloba a las clases \textit{WaterPlane}, manteniendo \textit{Object3D} como base, además de separando la funcionalidad de los frame buffers en la clase \textit{FrameBuffer} en una clase separada, aumentando la legibilidad de \textit{WaterObject}haciendo que, por ejemplo, los métodos \textit{bindReflectionFrameBuffer()} y \textit{unbindReflectionFrameBuffer()} pasen a ser \textit{reflectionFrameBuffer->bind()} y \textit{reflectionFrameBuffer->unbind()}. También se ha mantenido las clases \textit{Shader} y \textit{Camera3D}, extrayendo la lógica de actualización de matrices al proceso de renderizado de los objetos, simplificando el proceso de actualización de los shaders, que siempre se harán en sus propios objetos.
	
	Toda la lógica de la PEC está en la clase \textit{Pec2Effect}, con la mayor parte del trabajo en el método \textit{render}, puesto que \textit{update} se ocupa de gestionar la entrada del usuario.
	
	La clase \textit{WaterObject} final ha sido un buen sustrato para los objetos creados para esta PEC: una llama y un río de lava, que se explicarán en los próximos apartados.

\subsection{Llama}
	Este objeto con parte C++ \textit{FlameObject} y shader \textit{Flame} modela un fuego con dos partes bien definidas: la llama y una cortina de humo. Ambas partes se controlan desde el mismo shader vía una textura de máscara con forma de llama cuya superficie blanca delimita la llama y la negra será el fondo o cortina de humo, controladas por dos partes distintas del shader, aunque ambas tienen algo de transparencia implementada mediante una textura de refracción.

\subsubsection{Sección de llama}
	La llama es simplemente una superficie de un color amarillento salpicada con tonos negruzcos vía ruido de Perlin dinámico, cuya generación se ha obtenido de \cite{perlin-wlgl} y se ha abstraído en la función \textit{getPerlin} dentro del shader \textit{Flame.fragment}.
	
\subsubsection{Sección de humo}
	La sección de humo es un poco más compleja que la llama, puesto que además de realizar una pequeña distorsión del fondo, tiene un difuminado desde el centro de la pantalla de forma exponencial tipo $y=e^{-\alpha d^2}$,  siendo $d$ la distancia del punto al centro de la pantalla, en coordenadas de textura (función \textit{getAbsorptionFactor}). En este caso, el valor de $\alpha$ es tal que nos da una atenuación de $0.01$ a $d^2=1.2$, aproximadamente $1.01$ unidades de textura del centro de la pantalla.

\subsubsection{Shader: Flame}

	Tanto para la llama como para la lava, el shader de vértices es realmente simple, se limita a aplicar las matrices para hallar la posición en el espacio donde se encuentra el quad de dibujado y las coordenadas UV de la textura que le corresponde a ese vértice.

\input{flame_vertex}

	El grueso del procesado se encuentra en el shader de fragmento, donde la mayor parte del código se utiliza para el cálculo del ruido de Perlin usado en la llama extraído de github \cite{perlin-wlgl}. Como esa parte del código es externa al proyecto, no está incluida en la transcripción del shader más abajo. Primeramente se calcula el valor del fondo que corresponde al píxel, puesto que tanto la llama como el humo tiene transparencia, y dependiendo si el píxel es de llama o fondo se le aplica a este fondo su procesado.
	
	En el caso de que el píxel sea de llama, simplemente se hace un mix con el color del fuego aplicando el ruido de Perlin para simular el movimiento de la llama con una intensidad de $3.0$ para realzar la luz que emite el fuego. Y por último, si el píxel es del fondo, como se comentó antes, se le aplica una distorsión y una decoloración para simular el humo.

\input{flame_fragment}

\subsubsection{Intento fallido: Máscara dinámica}
	
		Para dar un poco más de realismo a la llama, intenté crear una máscara dinámica replicando el efecto de fuego visto en la práctica anterior, usando la matriz de convolución (\ref{conv-matrix}), aplicándola en cada frame a un framebuffer donde estaría ahora la máscara, añadiendo una línea de píxeles en la zona baja de la textura, tal y como se hacía en el apartado anterior. Esto se consigue teniendo varios estados en el shader, definidos por las variables \textit{initialize} y \textit{heat}, para indicar si se inicializa la textura (por defecto la textura de máscara original), se aplica la etapa de calor (activación de una línea de píxeles en la zona inferior de la textura), o la convolución del framebuffer con el filtro de fuego (\ref{conv-matrix}). Pero el único resultado conseguido ha sido una animación de expansión de la llama hasta llenar la pantalla, con lo que este intento ha sido descartado, pero creo que vale la pena señalarlo en esta memoria. Más abajo se añade el código del fragment shader final de este paso.
	
\begin{equation}
	\begin{pmatrix}
		0 & 0 & 0 & 0 & 0 \\
		0 & 0 & 0 & 0 & 0 \\
		0 & 0 & 0 & 0 & 0 \\
		0 & 1 & 1 & 1 & 0 \\
		0 & 1 & 1 & 1 & 0 \\
	\end{pmatrix}
	\label{conv-matrix}
\end{equation}

\begin{lstlisting}[style=glsl]
#version 330 core

in vec2 texCoord;

uniform bool initialize;
uniform bool heat;
uniform sampler2D texture1;
uniform float kernel[9];
uniform vec2 tex_offset[9]; // precomputed offsets
uniform float stepHeight;
uniform float stepWidth;

out vec4 FragColor;

bool isValidCoords(vec2 coords)
{
	return 0 < coords.x && coords.x < 1 && 0 < coords.y && coords.y < 1;
}

bool isValidCoords2(vec2 v)
{
	return v.y > 2.f*stepHeight &&
		stepWidth < v.x && v.x < (1 - stepWidth);
}

vec4 convolute()
{
	vec3 result;
	if(isValidCoords2(texCoord))
	{
		result = vec3(0.0, 0.0, 0.0);
		for (int i = 0; i < 9; i++)
		{
			vec2 coords = texCoord + tex_offset[i];
			vec3 texColor = (isValidCoords(coords)) ?
				texture(texture1, texCoord + tex_offset[i]).rgb : vec3(1,1,1);
			result += texColor * kernel[i];
		}
	}
	else
	{
		result = vec3(1,1,1);
	}

	return vec4(result.xyz,1);
}


void main()
{
	if (heat)
	{
		if (0.1 <= texCoord.y && texCoord.y <= 0.3)
		{
			FragColor = vec4(1,1,1,1);
		}
	}
	else
	{
		FragColor = (initialize) ? texture(texture1, texCoord) :
			convolute();
	}
}
\end{lstlisting}
	
\subsection{Lava}
	Este objeto está formado por la clase C++ \textit{LavaObject} y el shader \textit{Lava}. Este objeto es más simple que el anterior, aun compartiendo la misma estructura y cambiando la textura de refracción por una textura de reflexión.
	
\input{lava_fragment}
	
	

\section{Compilando el proyecto}
	Como se indicó al principio de este documento, el proyecto solo tiene como dependencias la librería básica SDL más las extensiones image, mixer y ttf. En el archivo main.cpp hay cuatro flags de depuración para poder mostrar por pantalla los fps actuales, el título del efecto actual (en el main, con lo que solamente saldrá el efecto \textit{PEC1AudioEffect}), el tiempo restante de simulación y la sección del tema musical que está activo actualmente. Por defecto está todo a $false$ para no tener distracciones en la pantalla, pero se pueden activar poniendo sus flags a true. Un ejemplo de estos flags en funcionamiento puede verse en el video \url{https://youtu.be/CDG5kHigrSQ} donde se ejecuta una serie con los efectos proporcionados para la PEC, tanto a resolución $640$x$480$ como a $1440$x$1080$.
	
\section{Conclusiones}
	En esta PEC se ha entregado una demo con varios efectos basados en los dados en los materiales para la PEC. Aunque se ha intentado mantener una temática sobre el cielo (imágenes de nubes y planetas, movimiento espiral de galaxia), no ha sido posible mantenerlo en todos los efectos. Es imposible aplicar esa temática en el efecto de flocking y no sería muy vistoso una imagen con tantos tonos oscuros en el de texturización, por poner un par de ejemplos. La experiencia en general aprendiendo sobre los efectos y diseñando los propios ha sido bastante buena, aun con el handicap de las técnicas de programación tan ``oscuras'' utilizadas en los códigos iniciales.
	
	Así, para suplir mis carencias artísticas, he optado por implementar un pseudo motor de ejecución de efectos en el que se inicializa un vector con la lista de efectos a ejecutar hasta un tiempo determinado o una condición predefinida, pasando de un efecto a otro mediante una transición aleatoria. Estas transiciones son facilmente ampliables, puesto que se trata de una función que define qué píxeles de la imagen pertenecen a cada uno de los efectos implicados en la misma.
	
%\begin{figure}[ht!]
	%\includegraphics[width=15cm]{./reaper-cover.png}
	%\caption{Carátula de Reaper -- Story of a Pale Swordsman.}
	%\label{reaper-cover}
%\end{figure}
	
\begin{thebibliography}{9}
\bibitem{perlin-wlgl} https://stegu.github.io/webgl-noise/webdemo/
\bibitem{shader-lava} https://www.shadertoy.com/view/WdKcRt
\end{thebibliography}
\end{document}
