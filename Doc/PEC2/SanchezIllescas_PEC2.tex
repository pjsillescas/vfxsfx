\documentclass[12pt]{article}%

\usepackage{amsmath}%
\usepackage{amsfonts}%
\usepackage{amssymb}%
\usepackage{graphicx}
\usepackage{array}
%\usepackage{hyperref}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}

\usepackage[a4paper, total={6in, 8in},margin=3cm]{geometry}
%\usepackage[a4paper, total={6in, 10in}]{geometry}

\renewcommand{\figurename}{Figura}

\begin{document}
\sloppy

\title{PEC2: Fuego en el Shader}
\author{Pedro Jesús Sánchez Illescas}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Librerías utilizadas}
\begin{itemize}
	\item SDL 2.30.0
	\item SDL-image 2.8.2
\end{itemize}

\section{Proceso de creación}
	
	Este proyecto se ha desarrollado partiendo del código del reto 15 del cuaderno junto con el minimotor de efectos desarrollado en la práctica anterior, con leves modificaciones para poder dibujar usando ventanas OpenGL en lugar de superficies y la posibilidad de usar input del usuario en los efectos. El primer paso ha consistido en refactorizar el código inicial con los objetivos de tener un código más compacto y profundizar en la comprensión del procedimiento. Gracias a este paso, el agua se ha renderizado usando un solo objeto \textit{WaterObject} que engloba a las clases \textit{WaterPlane}, manteniendo \textit{Object3D} como base, además de separando la funcionalidad de los frame buffers en la clase \textit{FrameBuffer} en una clase separada, aumentando la legibilidad de \textit{WaterObject}haciendo que, por ejemplo, los métodos \textit{bindReflectionFrameBuffer()} y \textit{unbindReflectionFrameBuffer()} pasen a ser \textit{reflectionFrameBuffer->bind()} y \textit{reflectionFrameBuffer->unbind()}. También se ha mantenido las clases \textit{Shader} y \textit{Camera3D}, extrayendo la lógica de actualización de matrices al proceso de renderizado de los objetos, simplificando el proceso de actualización de los shaders, que siempre se harán en sus propios objetos.
	
	Toda la lógica de la PEC está en la clase \textit{Pec2Effect}, con la mayor parte del trabajo en el método \textit{render}, puesto que \textit{update} se ocupa de gestionar la entrada del usuario.
	
	La clase \textit{WaterObject} final ha sido un buen sustrato para los objetos creados para esta PEC: una llama y un río de lava, que se explicarán en los próximos apartados.

\subsection{Llama}
	Este objeto con parte C++ \textit{FlameObject} y shader \textit{Flame} modela un fuego con dos partes bien definidas: la llama y una cortina de humo. Ambas partes se controlan desde el mismo shader vía una textura de máscara con forma de llama cuya superficie blanca delimita la llama y la negra será el fondo o cortina de humo, controladas por dos partes distintas del shader, aunque ambas tienen un nivel de transparencia.

\subsubsection{Sección de llama}

\subsubsection{Sección de humo}

\subsection{Lava}
	Este objeto está formado por la clase C++ \textit{LavaObject} y el shader \textit{Lava}. Este objeto es más simple que el anterior, 
	
	
	
	Todo el proyecto se ha realizado usando como base el código proporcionado para la práctica. Para empezar a usar todos los efectos en un mismo ejecutable, la primera fase del proyecto ha sido refactorizar la estructura de todos los efectos, viendo que todos los efectos tiene una estructura de inicialización, actualización y renderización. De esta manera, existe la clase abstracta \textit{EffectTemplate}, con los métodos \textit{init()}, \textit{update(deltaTime)} y \textit{render()}, que serán implementados en cada efecto. Estos efectos serán ejecutados por un algoritmo principal que empezará lanzando las inicializaciones, y los pares actualización $--$ renderización en cada frame, llevando también el cálculo del tiempo usando la clase \textit{Clock}, basada en los ticks de SDL. Esta clase proporciona los valores de tiempo entre frames (\textit{deltaTime}) y el tiempo total de ejecución para poder ser usados en los distintos efectos de una manera limpia.
	
	La entrega consta de un efecto principal que contiene el tema musical ``Road to Nowhere'' (\url{https://www.youtube.com/watch?v=7k5H-sDAxwc}), pieza sin copyright de Roman Dudchyk, junto con una serie de efectos que estarán sincronizados con cada una de las secciones del tema. Debido a la duración de la música, algo más de $3$ minutos, y para no repetir demasiado los efectos y quede una demo demasiado aburrida Entre estos efectos hay algunos que son exactamente los que vienen dados de ejemplo o tienen modificaciones muy ligeras como para que puedan ser consideradas como efectos personalizados (quitando el proceso de refactorización anteriormente citado).
	
	Seguidamente se muestra una lista con los efectos añadidos a la entrega. Los efectos sin modificaciones importantes vienen marcados como ``default''.
	
	\begin{itemize}
		\item \textit{BlackScreenEffect}: efecto simple que pinta la pantalla de negro usado como efecto dramático en los compases de cambio de sección.
		\item \textit{BarsEffect}
		\item \textit{FlockingEffect}
		\item \textit{PlasmaPec1Effect}: efecto ``default'' con una función personalizada de generación de patrones.
		\item \textit{FractalPec1Effect}: efecto ``default'' sin modificaciones del efecto de Mandelbrot.
		\item \textit{DistortionPec1Effect}: efecto `` default'' de distorsión con una imagen personalizada.
		\item \textit{SpyralEffect}
		\item \textit{WhirlpoolEffect}
		\item \textit{Pec1FlashEffect}
		\item \textit{TexturizationEffect}
		\item \textit{Pec1AudioEffect}
	\end{itemize}

\subsection{BarsEffect}
	Este efecto se empezó a desarrollar como una simulación de los barrotes de un campo de fuerza a partir de aplicar un filtro de detección de ejes al resultado del efecto de fuego, pero el resultado acabó pareciéndose más al efecto de una fotograma en pausa de las antiguas cintas VHS. El filtro total viene dada en la expresión (\ref{eq-matrix}).
	
\begin{equation}
	\begin{pmatrix}
		1 & 1 & 1 \\
		1 & -7 & 1 \\
		1 & 1 & 1 \\
	\end{pmatrix}
	\label{eq-matrix}
\end{equation}
	
	Al resultado de la convolución se le ha añadido un pequeño umbral variante en el tiempo mediante la ecuación $u=150 + 150\sin{(s t)}$, siendo $s=\frac{1}{BPM}$ y $t$ el tiempo de simulación para que los pulsos vayan al ritmo de la canción.
	
\subsection{FlockingEffect}
	Este algoritmo simula un movimiento coordinado e independiente entre partículas que están a una distancia cercana, basado en la clusterización de partículas según su posición e intentando mantener uniforme la velocidad media del cluster y las separaciones entre los elementos del mismo.
	Este algoritmo viene explicado en la url \url{https://medium.com/@pramodayajayalath/flocking-algorithm-simulating-collective-behavior-in-nature-inspired-systems-dc6d7fb884cc}.
	
\subsection{SpyralEffect}
	Este efecto representa el movimiento de los planetas formando galaxias. Es muy vistoso y fácil de implementar. Consiste en disponer de un número de partículas dispuestos sobre un plano, y se van desplazando en trayectorias circulares desde el centro de la pantalla siempre a la misma velocidad lineal. El tener todas las partículas la misma velocidad lineal hace que los puntos más cercanos al centro de la pantalla volteen el centro más rápidamente, creando los brazos de las galaxias y otras estructuras interesantes. 

\subsection{WhirlpoolEffect}
	Este efecto tiene una implementación más interesante, y consta de los siguientes pasos:
	\begin{enumerate}
		\item Construir un degradado radial a partir del degradado lineal dado en una textura.
		\item Añadir un tiling pasado por parámetro para generar varios discos en la pantalla.
		\item Implementar un offset de generación (píxel por donde se empieza a renderizar el degradado de forma cíclica).
		\item Aumentar el offset en función del tiempo de simulación a una velocidad $\frac{screenWidth}{2BPM}$ para que en cada golpe llegue un círculo al centro.
	\end{enumerate}

\subsection{Pec1FlashEffect}
	Este efecto de flash es una parte de la refactorización del efecto de sincronización entregado en los recursos de la práctica, pero en lugar de cambiar el alpha de un color hasta ser totalmente visible, el color se va haciendo invisible hasta dejar ver una imagen, que va cambiando de forma cíclica entre un grupo de imágenes dentro de la carpeta \textit{assets/flash}. Al igual que con los efectos anteriores, la velocidad de cambio es proporcional a la duración de un pulso de la canción para sincronizar los cambios de imágenes con la música.

\subsection{TexturizationEffect}
	Este efecto trata de texturizar un casquete esférico centrado en el origen, donde se encuentra la cámara, en lugar del interior del toro de la demo inicial. Para calcular los puntos de la esfera se utiliza la técnica de ``distancia2'', es decir, que en lugar de usar la ecuación tradicional $\sqrt{x^2 + y^2} = R$, se usa la expresión $x^2 + y^2 = R^2$, ahorrando las raíces cuadradas en todos los cálculos de todos los frames, con el consiguiente ahorro en rendimiento.

\subsection{Pec1AudioEffect}
	Este efecto es la base que, además de ejecutar la canción, se encarga de administrar e ir ejecutando los efectos visuales de la demo, haciendo las veces de una modificación de la función main para administrar la ejecución de los efectos anteriores.

\subsection{Transiciones}
	Las transiciones han sido diseñadas como efectos de segundo orden, que reciben dos efectos, fuente y destino, ya inicializados y se ocupan de ir actualizando ambos efectos y renderizando los píxeles que correspondan de cada uno de los efectos según un método abstracto \textit{useSourceBuffer(i, j)}, que devuelve true si hay que renderizar el píxel $(i, j)$ del efecto fuente en pantalla. En caso contrario, se usa el píxel del efecto destino. Se usa la terminología fuente -- destino porque la renderización final se hace en la superficie del efecto destino. Esta funcionalidad base se implementa en la clase \textit{TransitionEffect}, y actualmente hay tres implementaciones de transiciones:
	\begin{itemize}
		\item \textit{CircleTransitionEffect}: un círculo se va abriendo o cerrando desde / hacia el centro de la pantalla, dependiendo de la dirección del efecto, añadiendo cada vez más píxeles del destino.
		\item \textit{RowTransitionEffect}: en cada iteración se van añadiendo más filas del efecto destino a la imagen, ya sea de arriba a abajo o viceversa, según el sentido de la transición.
		\item \textit{ColumnTransitionEffect}: similar al anterior, pero en columnas de izquierda a derecha o viceversa.
	\end{itemize}
	
	En el menú main se usan directamente estos efectos para transicionar entre los efectos dados en un vector, pero para usarlos dentro del efecto de audio se ha optado por usar una clase extra \textit{EffectWithTransition} que tiene su efecto inicial (fuente) y final (destino). Esta clase elige una transición de forma aleatoria al iniciarse, y va revisando en cada frame si la transición ha terminado. En cuanto esto ocurre, solamente el efecto destino se ejecuta. De esta manera se puede usar transiciones de una manera razonablemente eficiente sin que resulte en un código muy denso, como ocurre con la función main, que primeramente ejecuta la transición con el efecto anterior y al terminar sigue ejecutando el efecto siguiente solo.
	
\section{Compilando el proyecto}
	Como se indicó al principio de este documento, el proyecto solo tiene como dependencias la librería básica SDL más las extensiones image, mixer y ttf. En el archivo main.cpp hay cuatro flags de depuración para poder mostrar por pantalla los fps actuales, el título del efecto actual (en el main, con lo que solamente saldrá el efecto \textit{PEC1AudioEffect}), el tiempo restante de simulación y la sección del tema musical que está activo actualmente. Por defecto está todo a $false$ para no tener distracciones en la pantalla, pero se pueden activar poniendo sus flags a true. Un ejemplo de estos flags en funcionamiento puede verse en el video \url{https://youtu.be/CDG5kHigrSQ} donde se ejecuta una serie con los efectos proporcionados para la PEC, tanto a resolución $640$x$480$ como a $1440$x$1080$.
	
\section{Conclusiones}
	En esta PEC se ha entregado una demo con varios efectos basados en los dados en los materiales para la PEC. Aunque se ha intentado mantener una temática sobre el cielo (imágenes de nubes y planetas, movimiento espiral de galaxia), no ha sido posible mantenerlo en todos los efectos. Es imposible aplicar esa temática en el efecto de flocking y no sería muy vistoso una imagen con tantos tonos oscuros en el de texturización, por poner un par de ejemplos. La experiencia en general aprendiendo sobre los efectos y diseñando los propios ha sido bastante buena, aun con el handicap de las técnicas de programación tan ``oscuras'' utilizadas en los códigos iniciales.
	
	Así, para suplir mis carencias artísticas, he optado por implementar un pseudo motor de ejecución de efectos en el que se inicializa un vector con la lista de efectos a ejecutar hasta un tiempo determinado o una condición predefinida, pasando de un efecto a otro mediante una transición aleatoria. Estas transiciones son facilmente ampliables, puesto que se trata de una función que define qué píxeles de la imagen pertenecen a cada uno de los efectos implicados en la misma.
	
%\begin{figure}[ht!]
	%\includegraphics[width=15cm]{./reaper-cover.png}
	%\caption{Carátula de Reaper -- Story of a Pale Swordsman.}
	%\label{reaper-cover}
%\end{figure}
	
\end{document}
